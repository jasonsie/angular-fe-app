# GitHub Copilot Review Instructions for Angular Project

## Core Development Philosophy

Review all code changes to ensure they align with our Angular application's emphasis on clean code architecture, following Object-Oriented Programming (OOP), SOLID principles, and Functional Programming (FP) paradigms.

## Angular Best Practices

### Component Architecture

-  Verify `OnPush` change detection strategy is used where appropriate.
-  Ensure proper implementation of lifecycle hooks (`OnInit`, `OnDestroy`, etc.).
-  Components should primarily handle presentation logic.
-  Check for usage of Angular Material components as defined in `material.config.ts`.
-  Confirm adherence to the component structure: template, styles, and logic separation.
-  Assess if standalone components are used appropriately.

### Services & Dependency Injection

-  Business logic and data management should reside in services.
-  Validate correct usage of Angular's dependency injection system.
-  Check for proper error handling and logging mechanisms in services.
-  Ensure RxJS operators are used for reactive programming patterns.
-  Verify services follow the established pattern in `core/services/`.

### TypeScript & Type Safety

-  Enforce strict TypeScript typing.
-  All data structures must have defined interfaces (following `core/interfaces/` pattern).
-  Check for appropriate use of union types, generics, and utility types.
-  Ensure type guards are implemented where necessary.

## SOLID Principles Implementation

### Single Responsibility Principle (SRP)

-  Each class, component, or service should have a single, well-defined responsibility.
-  Verify separation of concerns: presentation, business logic, and data access.
-  Modules should be focused and cohesive.

### Open/Closed Principle (OCP)

-  Classes should be designed to be open for extension but closed for modification.
-  Look for the use of inheritance, composition, and Angular's DI to achieve this.
-  Check for the use of abstract classes and interfaces for extensibility.

### Liskov Substitution Principle (LSP)

-  Derived classes must be substitutable for their base classes without altering a program's correctness.
-  Ensure behavioral compatibility in inheritance hierarchies.
-  Validate proper TypeScript inheritance patterns.

### Interface Segregation Principle (ISP)

-  Interfaces should be small and focused.
-  Classes should not be forced to depend on interfaces they do not use.
-  Large interfaces should be split into smaller, more specific ones.

### Dependency Inversion Principle (DIP)

-  Code should depend on abstractions, not on concrete implementations.
-  Verify Angular's DI system is used to inject dependencies.
-  Services should have interfaces, and implementations should be injected.

## Object-Oriented Programming Patterns

### Encapsulation

-  Check for appropriate use of `private`, `protected`, and `public` modifiers.
-  Assess if getters/setters are implemented when needed.
-  Internal implementation details should be hidden.

### Inheritance

-  Verify correct usage of the `extends` keyword.
-  Ensure proper constructor chaining.
-  Overridden methods should have proper signatures.

### Polymorphism

-  Look for the use of method overriding and interfaces.
-  Abstract methods should be implemented in derived classes.
-  TypeScript's type system should be leveraged for polymorphic behavior.

### Abstraction

-  Check if abstract base classes are used appropriately.
-  Interfaces and contracts should be clearly defined.
-  Complexity should be hidden behind simple APIs.

## Functional Programming Principles

### Immutability

-  `readonly` properties should be used where appropriate.
-  Prefer immutable operations (e.g., `map`, `filter`, `reduce` over direct modification).
-  Check for the use of the spread operator and `Object.assign` for object updates.
-  Ensure Angular's `OnPush` strategy is used with immutable data structures.

### Pure Functions

-  Functions should be free of side effects where possible.
-  Data transformations should ideally be handled by pure functions.
-  Logic should be predictable and testable.

### Higher-Order Functions

-  Verify effective use of RxJS operators.
-  Look for function composition patterns.
-  Array methods (`map`, `filter`, `reduce`) should be preferred over imperative loops.

### Function Composition

-  Operations should be chained using pipe operators (e.g., in RxJS).
-  Reusable transformation functions should be created.
-  Simple functions should be combined to build complex behaviors.

## Code Style & Patterns

### Naming Conventions

-  PascalCase: classes, interfaces, components.
-  camelCase: variables, methods, properties.
-  kebab-case: file names, selectors.
-  UPPER_SNAKE_CASE: constants.

### Error Handling

-  Proper error boundaries should be implemented.
-  RxJS `catchError` operator should be used for asynchronous operations.
-  Error messages should be meaningful.
-  Errors should be logged appropriately.

### Testing

-  Unit tests should be present for all components and services.
-  Angular Testing Utilities should be used.
-  Dependencies should be mocked properly.
-  Tests should follow the AAA (Arrange, Act, Assert) pattern.

### Documentation

-  Public methods and classes should have JSDoc comments.
-  Complex business logic should be documented.
-  README files for major features should be maintained.
-  Commit messages should be clear and descriptive.

## Design Patterns to Leverage

Refer to patterns in `template/DP/` and ensure they are applied correctly where applicable:

### Behavioral Patterns

-  **Observer**: For reactive programming with RxJS.
-  **Strategy**: For selecting algorithms at runtime.
-  **Command**: For encapsulating user actions.
-  **State**: For managing component states.

### Creational Patterns

-  **Factory**: For creating objects.
-  **Builder**: For constructing complex objects.
-  **Singleton**: For shared services (leveraging Angular's built-in singleton services).

### Structural Patterns

-  **Adapter**: For integrating with third-party libraries.
-  **Decorator**: For extending functionality.
-  **Facade**: For simplifying interactions with complex subsystems.

## Performance Considerations

-  `trackBy` functions should be used in `*ngFor` loops.
-  `OnPush` change detection strategy should be implemented.
-  Modules and components should be lazy-loaded where appropriate.
-  The `async` pipe should be used for observable subscriptions in templates.
-  Bundle size should be optimized (e.g., via tree-shaking).

## Security Guidelines

-  User inputs must be sanitized.
-  Angular's built-in security features should be utilized.
-  Proper authentication and authorization mechanisms should be in place.
-  Data should be validated at service boundaries.

## Environment Configuration

-  Configuration should use environment files (as per the established pattern).
-  Sensitive data must not be committed to source code.
-  Environment-specific settings should be properly implemented.

---

**Review Focus**: Prioritize clean, maintainable, and testable code that strictly adheres to these architectural guidelines. Provide specific feedback with references to these principles when violations are found.
